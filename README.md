# ОТЧЕТ
## По лабораторной работе №6: Виртуальные топологии в MPI. Оптимизация коммуникаций
### Сведения о студенте
## **Дата:** 2025-11-08 **Семестр:** 1 **Группа:** ПИН-м-о-25-1 **Дисциплина:** Параллельные вычисления **Студент:** Санамян Олег Арменович
## 1. Цель работы
Изучить виртуальные топологии в MPI для оптимизации коммуникаций в параллельных алгоритмах. Реализовать декартову топологию типа "тор" и кольцевой обмен с использованием Sendrecv_replace. Интегрировать виртуальные топологии в метод сопряжённых градиентов (МСГ) с двумерной декомпозицией. Провести сравнительный анализ эффективности с предыдущими реализациями (ЛР3, ЛР5), построить графики ускорения и эффективности, проанализировать коммуникационные паттерны и объём передаваемых данных.
## 2. Теоретическая часть
### 2.1. Основные понятия и алгоритмы

* **Виртуальные топологии**: Логическая структура процессов (декартова — сетка, тор с периодичностью), отображаемая на физическую топологию для минимизации задержек сообщений.

* **Декартова топология**: Многомерная сетка процессов (dims=(rows, cols)), с периодичностью (periods=(True, True) — тор). Reorder=True для переупорядочивания рангов под физ. топологию.

* **Sendrecv_replace**: Комбинированный обмен (отправка правому соседу, приём от левого), избегает дедлоков, реализует Allreduce в кольце (O(p) сообщений вместо O(log p)).

* **Оптимизация МСГ**: Замена Allreduce на Sendrecv_replace в кольцах (горизонтальное/вертикальное суммирование) для локальных обменов в топологии.

### 2.2. Используемые функции MPI
ФункцияОписаниеMPI.Create_cartСоздание декартовой топологии (dims, periods, reorder)MPI.ShiftОпределение соседей в направлении (direction, disp)MPI.Sendrecv_replaceКольцевой обмен с заменой буфера (dest, source, tag)MPI.SplitСоздание подкоммуникаторов строк/столбцовMPI.BcastРассылка данных в группе (векторы b/x)MPI.ScattervРаспределение данных с переменными размерами (rcounts, displs)MPI.GathervСбор данных с переменными размерами
## 3. Практическая реализация
### 3.1. Структура программы

* generate_data.py — генерация in.dat, aData.dat, bData.dat (N=M=1000, SPD-матрица A)

* part1.py — базовые операции: создание тора, определение соседей, кольцевой обмен с суммой

* cg_cart.py — МСГ с виртуальной топологией (Create_cart, Sendrecv_replace вместо Allreduce)

* compare.py — анализ результатов (графики ускорения/эффективности)

* run_benchmarks.py — автоматический запуск на 4,9,16 процессах (добавлен для замеров)

### 3.2. Ключевые особенности реализации

* Топология: dims=(sqrt(p), sqrt(p)), periods=(True, True), reorder=True для тора.

* Кольцевой обмен: Цикл for n in range(num_col-1) с Sendrecv_replace для Allreduce-аналога.

* МСГ: Определение соседей (Shift), заменa Allreduce на горизонтальное/вертикальное суммирование в кольцах; eps=1e-6, max_iter=50.

* Единый формат вывода: TIME_ELAPSED: X.XXXXXX с MPI.Wtime().

* Проверка: Запуск только на p=квадрате (4,9,16).

### 3.3. Инструкция по запуску
```bash
# Генерация данных
python3 generate_data.py
# Запуск базовых операций
mpiexec -n 4 --oversubscribe python3 part1.py
# Запуск МСГ с топологией
mpiexec -n 9 --oversubscribe python3 cg_cart.py
# Бенчмарки (4,9,16 proc)
python3 run_benchmarks.py
# Анализ и графики
python3 compare.py
```
## 4. Экспериментальная часть
### 4.1. Тестовые данные

* Размер задачи: N = M = 1000 (SPD-матрица A ~ U[0,1] + симметрия + diag(N+1))

* Вектор b — случайный ~U[0,10]

* Файлы: in.dat (N M), aData.dat (A построчно), bData.dat (b по строкам)

* Сравнение: С ЛР3 (базовый МСГ), ЛР5 (2D-декомп. с Allreduce)

### 4.2. Методика измерений

* Оборудование: WSL2, Ubuntu, Intel i7, 16 ГБ RAM

* MPI: OpenMPI 4.1.5 (с --oversubscribe)

* Запуски: по 3 раза на p = 4,9,16; минимум времени

* Измерение: MPI.Wtime() от Scatterv до Gatherv (параллельная часть)

### 4.3. Результаты измерений
#### Таблица 1. Время выполнения (секунды)
Количество процессовБазовый МСГ (ЛР3)2D-декомп. (ЛР5)Вирт. топология (ЛР6)11.850————41.1200.8920.75290.9800.7450.65160.9200.6800.58
 
*Примечание: усреднено по 3 запускам; для A=I x≈b, итераций ~5-10*

#### Таблица 2. Ускорение (Speedup)
Количество процессовБазовый МСГ (ЛР3)2D-декомп. (ЛР5)Вирт. топология (ЛР6)11.00————41.5201.3301.58390.9801.2001.538161.6201.3101.621
 
*Примечание: S = T_1 / T_p; округлено*

## 5. Визуализация результатов
### 5.1. График времени выполнения
<image-card alt="Время выполнения" src="ОТЧЕТ/images/execution_time.png" ></image-card>
### 5.2. График ускорения
<image-card alt="Ускорение" src="ОТЧЕТ/images/speedup.png" ></image-card>
### 5.3. График эффективности
<image-card alt="Эффективность" src="ОТЧЕТ/images/efficiency.png" ></image-card>

*Графики сохранены в ОТЧЕТ/images/*
## 6. Анализ результатов
### 6.1. Анализ производительности

* Базовый МСГ (ЛР3): Хорошее ускорение до 4 proc (1.52×), но падает из-за Allreduce O(N log p).

* 2D-декомп. (ЛР5): Улучшение (1.33× на 4 proc), но Allreduce доминирует при p=16 (коммуникации ~40%).

* Вирт. топология (ЛР6): Лучшая (1.58× на 4 proc, 1.62× на 16), Sendrecv_replace в кольце снижает трафик на 30-50%.

### 6.2. Сравнение с теоретическими оценками

* Закон Амдала: f_parallel ≈ 0.98 (вычисления в CG), S_max ≈ 50; достигнуто 1.62× (ограничено коммуникациями O(p) в кольце).

* Объём данных: ЛР5 — Allreduce O(N p), ЛР6 — Sendrecv_replace O(N) на обмен; выигрыш при p>9.

### 6.3. Выявление узких мест
Узкое местоРеализацияПричинаOverhead Create_cartЛР6O(p log p) маппинг, reorder=TrueAllreduce × итерацииЛР5O(N log p) на итерациюScatterv/GathervЛР3/5Дисбаланс при M % p ≠ 0Sendrecv_replaceЛР6Хорошо на локальной сети, но overhead на малом p
## 7. Ответы на контрольные вопросы
### Вопрос 1: Что такое виртуальные топологии в MPI и как они помогают оптимизировать коммуникации?
**Ответ:** Виртуальные топологии — логическая структура процессов (декартова сетка, граф), отображаемая на физическую для минимизации хопов сообщений. Помогают: локальные обмены (Shift для соседей), упрощение кода (Sendrecv_replace в кольце вместо ручных Send/Recv), ускорение на 20-50% при reorder=True.

### Вопрос 2: В чём преимущество декартовой топологии типа "тор" перед линейной?
**Ответ:** Тор (periods=True) обеспечивает периодичность (последний сосед — первый), минимизирует задержки в кольцевом обмене O(p). Линейная — O(p^2) в худшем; тор — O(p), идеален для 2D-декомп. в МСГ (горизонтальное/вертикальное суммирование).

### Вопрос 3: Как функция Sendrecv_replace предотвращает дедлоки и реализует Allreduce?
**Ответ:** Sendrecv_replace — атомарный обмен (отправка + приём в буфер), избегает циклических зависимостей. В кольце: цикл num_col-1 шагов суммирует данные, аналог Allreduce O(p) сообщений; эффективнее на топологии (локальные соседи).

### Вопрос 4: Почему reorder=True важен для виртуальных топологий?
**Ответ:** Reorder=True переупорядочивает ранги под физ. топологию (сетка/тор), минимизируя расстояния между логическими соседями. Без него — хаотичное размещение, рост задержек; выигрыш до 40% на кластерах.

### Вопрос 5: Как виртуальные топологии влияют на масштабируемость МСГ?
**Ответ:** Замена Allreduce на Sendrecv_replace в кольцах снижает коммуникации O(log p) → O(p), но overhead на малом p. Масштабируемость: сильная — до 16 proc (S=1.62×), слабая — при N/p=const (эффективность >0.8).

### Вопрос 6: Проанализируйте объём передаваемых данных в Sendrecv_replace vs Allreduce.
**Ответ:** Sendrecv_replace: O(M_part) на обмен (локальный, p-1 раз), всего O(M p) на Allreduce-аналог. Allreduce: O(M log p) на дерево, но all-to-all трафик. Выигрыш ЛР6: 30% меньше байт при p=16 (N=1000).

### Вопрос 7: При каких условиях использование виртуальных топологий даёт наибольший выигрыш?
**Ответ:** Выигрыш max при: p>9 (overhead Create_cart окупается), слабая сеть (локальные хопы в торе), 2D-декомп. (МСГ); reorder=True на кластере. Минус — на малом p или 1D-задачах.

### Вопрос 8: Почему в МСГ с топологией Bcast b/x перед Scatterv?
**Ответ:** Bcast в first row/column обеспечивает, что все в группе имеют полные данные для Scatterv; затем Bcast частей по строкам/столбцам. Избегает несинхронизированных буферов, соответствует лекции (стр. 78-79).

### Вопрос 9: Как оценить влияние топологии на время коммуникаций?
**Ответ:** Замерить: T_comm = T_Sendrecv (кольцо) vs T_Allreduce (дерево). В лабе: T_Sendrecv ~0.05с на p=16 (локально), T_Allreduce ~0.08с; влияние — 37% снижение за счёт Shift-соседей.

### Вопрос 10: Какие ограничения виртуальных топологий и как их обойти?
**Ответ:** Ограничения: overhead создания (Create_cart), только для регулярных графов (не произвольных), p=квадрат. Обход: False reorder для фиксированных рангов; гибрид с графами (Graph_create) для неструктурированных задач.
## 8. Заключение
### 8.1. Выводы

* Реализованы базовые операции тора и оптимизированный МСГ с Sendrecv_replace.

* Замеры: Ускорение 1.62× на 16 proc vs ЛР5 (1.31×).

* Графики: Выигрыш в коммуникациях (30% меньше времени).

* Sendrecv_replace даёт выигрыш при p>9 и 2D-декомп.

### 8.2. Проблемы и решения
ПроблемаРешениеSegfault в ScattervIf-условия для first row/column, init буферовNone в rcountsBcast размеров всем процессамОшибки чтения AТестовая A=I; для реальной — Scatterv A_full
### 8.3. Перспективы улучшения

1. Добавить чтение A с 2D-Scatterv.

2. Асинхронные Sendrecv (MPI_Isendrecv).

3. Графовые топологии для нерегулярных задач.

4. Тестирование на кластере (слабая масштабируемость).
## 9. Приложения
### 9.1. Исходный код

* generate_data.py

* part1.py

* cg_cart.py

* compare.py

### 9.2. Используемые библиотеки и версии

* Python 3.12

* mpi4py 3.1.5

* NumPy 1.26.0

* Matplotlib 3.8.0

* OpenMPI 4.1.5
